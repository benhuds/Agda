{-
  Translation from source types and expressions
  to complexity types and expressions
  *see page 9 of paper
-}

open import Preliminaries
open import Source-lang
open import Comp-lang

module S-CTranslation where

  -- translation from source types to complexity types
  mutual
    ⟨⟨_⟩⟩ : Tp → CTp
    ⟨⟨ unit ⟩⟩ = unit
    ⟨⟨ nat ⟩⟩ = nat
    ⟨⟨ susp A ⟩⟩ = || A ||
    ⟨⟨ A ->s B ⟩⟩ = ⟨⟨ A ⟩⟩ ->c || B ||
    ⟨⟨ A ×s B ⟩⟩ = ⟨⟨ A ⟩⟩ ×c ⟨⟨ B ⟩⟩

    ||_|| : Tp → CTp
    || τ || = C ×c ⟨⟨ τ ⟩⟩

  ⟨⟨_⟩⟩c : Source-lang.Ctx → Comp-lang.Ctx
  ⟨⟨ [] ⟩⟩c = []
  ⟨⟨ x :: Γ ⟩⟩c = ⟨⟨ x ⟩⟩ :: ⟨⟨ Γ ⟩⟩c

  -- need to fill this out
  postulate lookup : ∀{Γ τ} → τ Source-lang.∈ Γ → ⟨⟨ Γ ⟩⟩c Comp-lang.|- ⟨⟨ τ ⟩⟩

  -- translation from source expressions to complexity expressions
  ||_||e : ∀{Γ τ} → Γ Source-lang.|- τ → ⟨⟨ Γ ⟩⟩c Comp-lang.|- || τ ||
  || unit ||e = prod 0C unit
  || var x ||e = prod 0C (lookup x)
  || z ||e = prod 0C z
  || suc e ||e = prod (plusC 1C (l-proj (|| e ||e))) (suc (r-proj (|| e ||e)))

  || rec e e0 e1 ||e = prod (plusC (l-proj (|| e ||e)) (l-proj (rec (r-proj || e ||e) || e0 ||e || e1 ||e))) 
                            (r-proj (rec (r-proj || e ||e) || e0 ||e || e1 ||e))
  || lam e ||e = prod 0C (r-proj (|| lam e ||e))
  || app e1 e2 ||e = prod (plusC (plusC (l-proj (|| e1 ||e)) (l-proj (|| e2 ||e))) (l-proj (app (r-proj (|| e1 ||e)) (r-proj (|| e2 ||e)))))
                          (r-proj (app (r-proj (|| e1 ||e)) (r-proj (|| e2 ||e))))
  || prod e1 e2 ||e = prod (plusC (l-proj (|| e1 ||e)) (l-proj (|| e2 ||e))) (prod (r-proj (|| e1 ||e)) (r-proj (|| e2 ||e)))
  || l-proj e ||e = prod (l-proj (|| e ||e)) (l-proj (r-proj (|| e ||e)))
  || r-proj e ||e = prod (l-proj (|| e ||e)) (r-proj (r-proj (|| e ||e)))
  || delay e ||e = prod 0C (|| e ||e)
  || force e ||e = prod (plusC (l-proj (|| e ||e)) (l-proj (r-proj (|| e ||e)))) (r-proj (r-proj (|| e ||e)))

  || split e0 e1 ||e = prod (plusC (l-proj (|| e0 ||e)) (l-proj {!!})) {!!}

  data vbNat : Set where
    z : vbNat
    s v : vbNat → vbNat

  mutual
    valBound : ∀{τ} → (e : [] Source-lang.|- τ) → val e → [] Comp-lang.|- ⟨⟨ τ ⟩⟩ → Set
    valBound a b c = {!!}

    {-valBound : ∀{τ} → [] Source-lang.|- τ → [] Comp-lang.|- ⟨⟨ τ ⟩⟩ → Set
    valBound unit d = {!!}
    valBound (var x) d = {!!}
    valBound z d = {!!}
    valBound (suc e) d = {!!}
    valBound (rec e e₁ e₂) d = {!!}
    valBound (lam e) d = {!!}
    valBound (app e e₁) d = {!!}
    valBound (prod e1 e2) d = valBound e1 (l-proj d) × valBound e2 (r-proj d)
    valBound (l-proj e) d = {!!}
    valBound (r-proj e) d = {!!}
    valBound (delay e) d = expBound e (r-proj d)
    valBound (force e) d = {!!}
    valBound (split e e₁) d = {!!}-}

    expBound : ∀{τ} → [] Source-lang.|- τ → [] Comp-lang.|- ⟨⟨ τ ⟩⟩ → Set
    expBound {n} e b = evals e {!n!} {!!} → {!!}
